<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[eslint_config]]></title>
    <url>%2F2017%2F10%2F25%2Feslint_config%2F</url>
    <content type="text"><![CDATA[EsLint是什么？Eslint是一个基于node的代码检测工具，通过对检测规则的配置，帮助我们==约束和规范代码==。 EsLint可以做什么？减少我们在开发中犯的一些==不符合团队代码规范==的小错误，如： 字符串是用单引号还是双引号 缩进的控制 括号间的空格 当然，Eslint还可以检测中你在代码中一些==语法问题==，如： 重复声明变量 使用了未声明的变量 漏掉的结束符，如&nbsp;&nbsp;&nbsp;&nbsp;}、） 其他的一些语法错误 通过ESLint插件，可以检测es6、jsx、react、react-native、vue、angular等等中的语法问题 ESLint使用方法命令行的使用方式在你的terminal中，键入ESLint命令，如在提交代码到远程仓库的时候想先通过ESLint检测一下我写的代码，在项目根目录键入以下命令： 1eslint --ext .js src test 可以检测src和test文件夹下所有的js文件，并将错误信息输出到终端中。还有更多的命令，请参考官方文档 配合编辑器使用通过编辑器插件，可以做到在书写代码的过程中实时检查错误，在下面会介绍如何使用编辑器做到实时检测代码问题。 不想看配置了，直接看怎么使用 EsLint配置 ESLint被设计是完全可配置的，这意味着你可以关闭每一个规则，只运行基本语法验证，或混合和匹配绑定的规则和自定义规则，以让 ESLint 更适合于你的项目。 目前有两种主要的方式来配置ESLint: Configuration Comments - 使用JavaScript注释把配置信息直接嵌入到一个文件。 Configuration Files - 使用 JavaScript、JSON 或者 YAML 文件为整个目录和它的子目录指定配置信息。可以用 .eslintrc.* 文件或者在 package.json 文件里的 eslintConfig 字段这两种方式进行配置，ESLint 会查找和自动读取它们，再者，你可以在命令行指定一个配置文件。 在package.json中配置 [不推荐] 1234567891011121314// package.json&#123; &quot;name&quot;: &quot;eslint-plugin-sunsharing&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;eslintConfig&quot;: &#123; &quot;extends&quot;: &quot;eslint:recommended&quot;, &quot;env&quot;: &#123; &quot;node&quot;: true &#125;, &quot;rules&quot;: &#123; &quot;no-console&quot;: &quot;off&quot; &#125; &#125;&#125; - 项目根目录下新建一个.eslintrc.*的文件，例如新建一个.eslintrc的文件 12345678910// .eslintrcmodule.exports = &#123; extends: &apos;eslint:recommended&apos;, env: &#123; node: true, &#125;, rules: &#123; &apos;no-console&apos;: &apos;off&apos;, &#125;,&#125;; - ==.eslintrc==的优先级高于==package.json==的ESLint配置 ESLint的配置项说明 parserOptions 设置解析器选项 ecmaVersion： 用来指定你想使用的ECMAScript版本，默认为5，也可以设置6、7、8等版本，对应ECMAScript2015、ECMAScript2016、ECMAScript2017。 sourceType： 可配置==script==和==module==，可以理解为你的代码是以何种形式存在的，如我们的代码是ECMAScript模块，则设置成module ecmaFeatures： 此属性值为一个对象，用来设置额外的语言特性 jsx：启用jsx，但并不支持React中jsx，如果需要检测React中jsx，需要使用eslint-plugin-react globalReturn：允许在全局作用域下使用==return==语句 impliedStrict：启用全局的==strict mode== experimentalObjectRestSpread：启用对实验性的==object rest/spread properties==的支持。（对象的解构赋值） 123456789101112module.exports = &#123; &quot;parserOptions&quot;: &#123; &quot;ecmaVersion&quot;: 6, &quot;sourceType&quot;: &quot;module&quot;, &quot;ecmaFeatures&quot;: &#123; &quot;jsx&quot;: true, &quot;globalReturn&quot;: true, &quot;impliedStrict&quot;: true, &quot;experimentalObjectRestSpread&quot;: true &#125; &#125;,&#125; parser 设置解析器 如下，我们将eslint的解析器设置成==babel-eslint==，babel-eslint是对==babel解析器==的包装使其与 ESLint 兼容，因为我们可能通过babel将我们的JavaScript编译成各个标准的代码。 需要本地安装这个模块 1npm install babel-eslint --save-dev 12345module.exports = &#123; &quot;parset&quot;: &quot;babel-eslint&quot;, &quot;parserOptions&quot;: &#123;/* ... */&#125;, &#125; env 配置预定义的环境变量 如es6中的==Set==、==Map==内建对象，eslint并不认识并且会==throw error==，开启了es6配置后，eslint就认识了。 更多的环境变量，请查阅官方文档 12345678910module.exports = &#123; &quot;parset&quot;: &quot;babel-eslint&quot;, &quot;parserOptions&quot;: &#123;/* ... */&#125;, &quot;env&quot;: &#123; &quot;browser&quot;: true, &quot;commonjs&quot;: true, &quot;es6&quot;: true, &quot;jquery&quot;: true &#125;&#125; globals 配置全局变量 不同于env的环境变量，globals允许我们配置一些全局变量，配置的全局变量会通过no-undef规则的校验。 123456789module.exports = &#123; &quot;parset&quot;: &quot;babel-eslint&quot;, &quot;parserOptions&quot;: &#123;/* ... */&#125;, &quot;env&quot;: &#123;/* ... */&#125;, &quot;globals&quot;: &#123; &quot;var1&quot;: true, // true允许该变量被重写 &quot;var2&quot;: false // false不允许该变量被重写 &#125;&#125; plugins 配置ESLint插件 插件可以增强ESLint的能力，如ESLint本身并不支持React中的jsx校验，则可以通过安装eslint-plugin-react和eslint-plugin-jsx-a11y来解决这个问题。 1234567module.exports = &#123; &quot;parset&quot;: &quot;babel-eslint&quot;, &quot;parserOptions&quot;: &#123;/* ... */&#125;, &quot;env&quot;: &#123;/* ... */&#125;, &quot;globals&quot;: &#123;/* ... */&#125;, &quot;plugin&quot;: [&apos;react&apos;, &apos;jsx-a11y&apos;]&#125; rules ESLint的最重要的功能，配置具体的校验规则 ==rules==属性是一个对象，支持多个规则。 对象的各个==key==对应着规则的ID，如==no-console==[规则ID] 或者 ==react/no-string-refs==[插件名/规则ID]。 对象的==value==接受字符串或者数组配置，数组的第一项总是规则的严重程度。 ==off== 或 ==0== 对应着规则关闭 ==warn== 或 ==1== 对应着开启规则，并对违反规则的使用警告级别的提示 ==error== 或 ==2== 对应着开启规则，并对违反规则的使用错误级别的提示 123456789101112module.exports = &#123; &quot;parset&quot;: &quot;babel-eslint&quot;, &quot;parserOptions&quot;: &#123;/* ... */&#125;, &quot;env&quot;: &#123;/* ... */&#125;, &quot;globals&quot;: &#123;/* ... */&#125;, &quot;plugin&quot;: [&apos;react&apos;, &apos;jsx-a11y&apos;], &quot;rules&quot;: &#123; &quot;no-console&quot;: &quot;off&quot;, &quot;quotes&quot;: [2, &quot;single&quot;], &quot;react/no-string-refs&quot;: [&quot;error&quot;] &#125;&#125; settings 自定义规则中可以访问到的信息 1234567891011module.exports = &#123; &quot;parset&quot;: &quot;babel-eslint&quot;, &quot;parserOptions&quot;: &#123;/* ... */&#125;, &quot;env&quot;: &#123;/* ... */&#125;, &quot;globals&quot;: &#123;/* ... */&#125;, &quot;plugin&quot;: [&apos;react&apos;, &apos;jsx-a11y&apos;], &quot;rules&quot;: &#123;/* ... */&#125;, &quot;settings&quot;: &#123; &quot;data&quot;: &apos;sunsharing&apos; &#125;&#125; root 指定ESLint是否向父级目录中寻找配置文件 一般我们会在项目目录中指定一个.eslintrc文件，它将作用于整个项目目录，如果希望项目目录下的某个目录应用不同的ESLint配置，则可以在该目录下新建一个.eslintrc文件，该目录会同时应用两个.eslintrc的配置，并且最靠近该目录的.eslintrc的配置将覆盖父级的.eslintrc配置。 如果我们指定了==root：true==，则会停止在父级目录中寻找其他的.eslintrc配置，默认为==false==，即会向上寻找。 12345678910module.exports = &#123; &quot;parset&quot;: &quot;babel-eslint&quot;, &quot;parserOptions&quot;: &#123;/* ... */&#125;, &quot;env&quot;: &#123;/* ... */&#125;, &quot;globals&quot;: &#123;/* ... */&#125;, &quot;plugin&quot;: [&apos;react&apos;, &apos;jsx-a11y&apos;], &quot;rules&quot;: &#123;/* ... */&#125;, &quot;settings&quot;: &#123;/* ... */&#125;, &quot;root&quot;: true&#125; extends 一个配置文件可以被基础配置中的已启用的规则继承 一个配置允许继承指定的配置，继承规则参考JavaScript的Object合并 ESLint内置了一些规则方案：如==eslint:recommended==或者==eslint:all==，前者将应用ESLint的推荐的核心规则，后者将会应用所有的核心规则。 1234567891011module.exports = &#123; &quot;parset&quot;: &quot;babel-eslint&quot;, &quot;parserOptions&quot;: &#123;/* ... */&#125;, &quot;env&quot;: &#123;/* ... */&#125;, &quot;globals&quot;: &#123;/* ... */&#125;, &quot;plugin&quot;: [&apos;react&apos;, &apos;jsx-a11y&apos;], &quot;rules&quot;: &#123;/* ... */&#125;, &quot;settings&quot;: &#123;/* ... */&#125;, &quot;root&quot;: true, &quot;extends&quot;: &apos;./config/index.js&apos;&#125; 添加.eslintignore文件来忽略不想被ESLint检测的文件这是一个纯文本文件，参考.gitignore。每一行都是一个glob模式表明一个文件定位。 也可以通过命令行来指定特定的文件用来替代.eslintignore的作用 [不推荐] 我们更提倡通过配置文件来配置ESLint而不是通过命令行。 1eslint --ignore-path .jshintignore file.js 也可以通过配置package.json来替代.esllintignore文件1234567891011&#123; &quot;name&quot;: &quot;sunsharing&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;eslintConfig&quot;: &#123; &quot;env&quot;: &#123; &quot;browser&quot;: true, &quot;node&quot;: true &#125; &#125;, &quot;eslintIgnore&quot;: [&quot;hello.js&quot;, &quot;world.js&quot;]&#125; 讲了那么多的配置，现在我们就来结合编辑器来使用ESLint。 为什么ESLint要配合编辑器使用在上文中提到使用方式中第一种是使用命令行来校验代码，但这很低效，总不能我写一行想看看代码有没有违反什么规范就要跑一次命令吧，低效且累人，命令的方式一般应用在你要push到你的远程仓库的时候跑一次代码测试。 编辑器插件就帮我们解决了上面的问题，插件会起一个server，它在监听我们文件的改动，每次代码的改动，插件都将自动帮我们进行校验。 准备工作 如果你只想在某个项目中使用ESLint，我们可以在项目根目录下执行 1npm install eslint --save-dev 如果想使ESLint适用于你所有的项目，建议使用全局安装。额外用到的eslint-config或者eslint-plugin也需要全局安装。 1npm install eslint -g 这里我推荐本地安装 VSCode篇 首先在VSCode的插件扩展面板中安装ESLint插件 安装后需要点击重新加载 在项目根目录下执行==eslint –init==命令会生成一个.eslintrc的配置文件，也可以通过复制其他项目的.eslintrc文件，配置的内容已在上文中讲述。 打开vscode的首选项设置，进行一些eslint的配置 ==eslint.enable==默认开启，这里可以将==eslint.autoFixOnSave==设置为==true==，这样你在vscode中保存文件的时候就可以执行==eslint –fix==命令 这时候点击vscode右下角的ESLint字样，可以看到 到这里就结束了，你可以在你的代码中加一些违反规范的代码，然后就可以看到ESLint给你的提示了，如果是一些可以通过==eslint –fix==命令修复的错误，你按下==ctrl+s==就可以看到错误被自动更正了！ WebStorm篇 打开 File&gt;Setting ， 找到ESLint选项，将==Enable==勾选起来 关闭ESLint的自身检查，只保留ESLint选项 至此，不符合规范的代码就将在WebStorm中标红]]></content>
      <tags>
        <tag>eslint</tag>
        <tag>config</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我没有钱]]></title>
    <url>%2F2017%2F08%2F23%2Fmoney%2F</url>
    <content type="text"><![CDATA[生活可以没有什么。生活必须有什么。活着的出路是什么。吾日三省吾身。如果一切都奔着钱去，生活会很累吧。可是钱，比什么都更容易给你带来幸福感，多想混吃等死然后又有好多钱啊😁~哈哈哈。你还要不要面子哦。你还别说，面子能值几个钱~ 生活可以没有贫穷。 生活必须有钱。 活着的出路是赚很多钱改变世界。（圈起来重点！）]]></content>
      <tags>
        <tag>瞎掰</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊天]]></title>
    <url>%2F2017%2F08%2F20%2Fnew_life%2F</url>
    <content type="text"><![CDATA[聊天背景：两有为青年 打工，不可能的，这辈子都不可能打工的。 那你现在在干啥？ 在做不可能的事. 那你很棒棒哦~ 可不是嘛! 吃屎吧你! 干嘛骂人呢！喂~站住！草泥马，赛林木，干林良。]]></content>
      <tags>
        <tag>瞎掰</tag>
      </tags>
  </entry>
</search>
